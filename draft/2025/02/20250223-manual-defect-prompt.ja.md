あなたは、DenoのCLIツールのエラーを修正開発しています。以下の指示全てに順序よく従ってください。

# 現状把握の段階

この段階では、ソースコードへの変更は禁止です。 テストがエラーになっているため、エラーを把握します。

```bash
deno test -A --env
```

次に、直近の変更点を確認します。

```bash
git --no-pager diff
```

ここまでで現状確認を終わります。 次に、エラーの発生源調査を進めます。

# エラーの発生源調査の段階

この段階では、ソースコードへの変更は禁止です。

テストでエラーが起きた箇所を起点に、ソースコードのつながりを3段階追いかけて把握します。

## 発生源の類似パターン調査

抽出した関連ソースのうち、エラーを引き起こしているソースコードの利用箇所を洗い出せるよう、キーワードを10個抽出します。なお
assert などのtestやエラー発生を意図したキーワードは除きます。（worktree-*ディレクトリは除きます。）

それらキーワードをgrepし、現在の実装を拾い出します。

```bash
rg -r "<キーワードを正規表現のOR条件で繋げる>" */*.ts
```

# 実装スコープを定める段階

この段階では、ソースコードへの変更は禁止です。

git
diffの内容と、ソースコードのつながりの情報をもとに、修正のスコープを定めます。具体的には、変更するファイルと修正する関数を決めます。
変更から影響を受ける箇所は、同じスコープに入れてください。
引数や変数の値に依存するエラーの場合、ソースコードの修正はMustではありません。

実施内容はプロジェクト直下の `tmp/task.md` へ記録します。

# 改修案の検討

複数の視点で、最低３つの変更案を議論して導きだしてください。 1:テスト駆動設計の視点,
2:既存実装優先の視点, 3:保守容易性の視点, 4:変更範囲最小化の視点, 5:変更への耐性・堅牢性の視点

これらを `tmp/task.md` へ記録します。

## 改修案の検証

検討した変更案に対し、既存テストがエラーを起こす可能性を0%..100%で評価して、`tmp/task.md`
へ記録します。

# 改修の段階

ソースコードへの変更を許可します。 `tmp/task.md` へ記録した内容をもとに、実装を修正してください。
進行するたびに、`tmp/task.md`へ完了チェックを入れてください。

## Check point テストの実施

1. 実装の入力から出力を追います。
2. プロセスに主要なチェックポイントを設け、テストの実装に加えます。
3. 段階的なテストのチェックポイントをpassする・しないによって、エラー発生時の切り分けを容易にします。

## 守ること

今必要ではない機能を過剰に追加しない。
変更不要の場合は「差分はありません。変更は不要です。」と報告して終了する。

# 完了確認の段階

この段階では、ソースコードへの変更は禁止です。

正しく動作することを確認してください。

```bash
deno test -A
```

以上が、DenoのCLIツールを修正開発するための、あなたへの指示です。

# エラー分析

エラーが起きました。以下の３ステップを処理し、問題を継続的に把握しなさい。結果を tmp/task.md
の「エラー発生履歴」段落に記載（あれば更新）しなさい。

- a.既存エラー、b.新規エラーを区別しなさい。２回目以降の同一エラー発生は全てaです。
- x.テストコードに起因、y.既存コードに起因、z.新規追加コードの起因を区別しなさい。
- n.エラー発生箇所ごとのエラー発生回数、m.トータルの修正回数、p.改修箇所ごとの修正回数
- o.以前生じていたがpassするようになったエラーのpass回数

## tmp/task.md 記載例

```
b. 新規エラー (z: 新規追加コード起因)
- input オプションの値が undefined (n=2)
```

次に、 a&n>2は問題解消ができていません。一歩引いた目線で解決策を考えなさい。
a&p=0は問題に手を打てていません。エラー箇所を起点にステップを追いなさい。意図的に未着手の場合は問題ありません。
a&m>10は問題が複雑化しています。問題の構造を把握するためソースコードを多面的に、複合的に３ステップ以上追いかけてください。
b&xはテストコードを修正します。
b&y,b&zは仕様変更に見合ったチェックポイントをテストに設けて、問題の切り分けを行います。

# 解決方法の探索

１エラーのみを修正し、１つずつ改善します。

問題の追い方： 解決する対象のエラーを１つ選びます。 入力と出力を１処理とします。
エラー1つに対し、１処理が通る中間処理を全て洗い出します。

問題の切り分け方： 問題の範囲を限定するために、境界線を引くよう、テストを分割してください。
問題を追ったうえで、中間ポイントの中で値の受け渡しの箇所を主なチェックポイントとします。
例えば、関数のレスポンスを別の関数の引数として利用するなど。

探索結果の記録： 問題点を把握し、チェックポイントを設けたうえで、修正案を考え tmp/task.md
へ記しなさい。（linterエラーは全て無視する。）

スコープの切り分け方：

- 仕様追加部分を 1.インプトットの起点, 2.プロセス で分けます。
- 2.プロセスは、中間ポイントの中で値の受け渡しの箇所をチェックポイントとします。 　
  例えば、関数のレスポンスを別の関数の引数として利用するなど。
- 1&2の組み合わせが改修単位、すなわち改修単位ごとのスコープとなります。

引き続き、修正の適用後にエラーが発生した。

1.

直前(1回)の変更による影響を分析して。 1-1. 1つ前のエラーと今回のエラーの差分を比較する(差分A) 1-2.
差分Aをもとに、解消した問題と、残っている問題と、新しい問題に分ける 1-3.
分けた結果ごとに、最新エラーの状況を分析する。 1-4. 分析結果を tmp/task.md へ反映する（更新する）。

2.

エラー内容を、入力から出力までの段階ごとに追いかけて。また、それぞれのソースコードを深掘り参照し、エラーの発生経路を解析して。
2-1. 追いかけた経路を、tmp/task.md の「構造把握」段落へMermaidの関連図で記載(すでにあれば更新)する。
2-2. ファイルや関数の依存関係と、エラー発生の因果関係を表すこと。 2-3.
その後、既知の問題と、新規の問題に分けて。 2-3-1. 既知の問題は、検討済みの対応を進めて。 2-3-2.
新規の問題は、対応を検討する必要がある。 2-3-2-1. 追跡した結果をもとに修正案を検討する。 2-3-2-2.
5Why
による検証を具体的なコードに対して実施する。whyステップは入力から出力までのコードの追跡の深さになる。
2-3-2-3.
5Why分析に基づき、修正案をブラッシュアップする。特にエラーの種類を分析し、起きている事象を細かく把握したうえで対応を練ること。
2-3-2-4. tmp/task.md の「対応内容」に、修正案をタスクとして記載する。 2-4.
「対応内容」に記載したタスクには、「根拠」を示すこと。 2-4-1.
根拠は、修正した結果、「仕様を維持したままエラーが解消する」と考えられるコードの依存関係や処理の説明を指す。
2-4-2. 根拠が不足した対応タスクは、検討が甘いため、ソースコードの追跡調査を追加で行うこと。 2-5.
分析結果を tmp/task.md へ反映する（更新する）。 2-6. 仕様 @breakdown と比較し、@task.md
`tmp/task.md` をUpdateする。 その後、修正を開始する。

エラーになったテストが、@config.md @app_config.ja.md @app_prompt.ja.md @app_schema.ja.md
@breakdown.ja.md @options.ja.md の仕様に対して、適切なテストかどうかを評価して。

1. 全てのテストを @task.md の「テスト項目リスト」（なければ設ける）へ記載する。
2. テスト項目リストの各項目が、仕様書のどの目的を検査しているか具体的に書く
3. テストの成功と失敗の定義を併記し、テストがpassするべき事柄を書く

# テスト実施記録

- この「テスト項目リスト」に、「実施回数」「成功数」「失敗数」を追加する。
- 今回の失敗が１回となる。
- テスト項目にはユニークなキーを割り当てる。Hash値で良い。「テストID」と呼ぶ。
- 各テストIDの専用ファイル（テストIDファイル）を、 tmp/test/testid.ja.md
  として保存し、実行記録をきさしていく。

# テストの修正記録

- テストIDファイルに実施履歴を記載する。
- 修正した内容を「path '../deps.ts' を '../../deps.ts'へ修正」のように記載する
- テストIDファイルには、テストが確かめている仕様の説明を記載する。仕様書ファイルと行番号、仕様のサマリー、テストへの期待結果。

まずは、テスト項目リストのうち、最初のテストから実施し、最後のテストまで順次実行して。

# 振り返り

PDCA(修正計画→修正実行→テスト結果のチェック→修正案の最適化)の結果チェックと修正案の最適化を行う。
まず tmp/task.md の「テスト項目リスト」を更新する。

## テスト実施記録の再評価

- 「テスト項目リスト」に、「実施回数」「成功数」「失敗数」を加算する。
- 各テストIDの専用ファイル（テストIDファイル）が、 tmp/test/testid.ja.md として保存されているため、
  　実行結果を反映する。

## テスト修正記録の最適化

- テストIDファイルに実施履歴を記載する。
- 修正した内容を「path '../deps.ts' を '../../deps.ts'へ修正」のように記載する
- 修正とエラーの内容から得られた「学び」を追記する。過去の学びを踏まえて、知見をUpdateする。
- 学びがコインの裏返しやトートロジーにならぬよう、因果関係をふかぼって解決に向かう学びとする
  - NG例. 学び:
    テストフレームワークがエラー出力をキャプチャする仕組みを理解し、それに合わせた実装が必要
  - OK例. 学び: 作業ディレクトリのパスを `.agent/breakdown`
    に変更したら直ると思ったが、同じエラーが出たのでパスの変更は主因ではない

# 修正計画と実行

PDCA(修正計画→修正実行→テスト結果のチェック→修正案の最適化)の修正計画立案と実行を行う。

## テスト修正案の実装計画

- 各テストIDの専用ファイル（テストIDファイル）が、 tmp/test/testid.ja.md として保存されている
- 仕様と学びをもとに、新たな「修正案」を立案する
- エラー箇所の発生起因を、入力から出力の各段階のステップで理解する
  - ex1. 関数の結果→次の関数の引数に渡す
  - ex2. 出力の結果→ファイルへの保存→次の処理で読み込み
- 仕様やテストの目的に照らし、エラーの発生原因の取り除き方を決める

## テスト修正案の実行

- 実行計画に合わせて、テストの修正を行い、テストファイルへ適用する。
- 修正した内容を「path '../deps.ts' を '../../deps.ts'へ修正」のように「テストIDファイル」へ記載する

再度：最新指示：07:06 @task.md
に、テストエラーが出た一覧が記載されている。新エラーは一覧へ追記し、解消したエラーは完了をマークする。
実行回数、失敗回数、pass回数を同時に記録する。すでに存在する場合は件数カウントを加える。

問題の発生した箇所へ、詳細をdebug_loggerでログに出力する処理を加え、詳細把握が可能な追加処理を行う。

その後、エラーを修正する。
修正は、単純な問題と複雑な問題を分けて対応して。再発が続く問題・複雑な問題は、依存関係や影響範囲を考慮し広い目線で修正を行うこと。
再発問題には、一貫した実装が求められるので、修正方針を @task.md へ記録し一貫性を確保する。

なお、修正後、あなたはレビュワーに立場を変えて、修正箇所とエラー内容を突き合わせてフィードバックすること。なお同じエラーが繰り返されている場合、あなたは解雇される危機にあります。危機感を持って対応してください。

なお、修正後、あなたはレビュワーに立場を変えて、修正箇所とエラー内容を突き合わせてフィードバックすること。同じエラーが繰り返されている場合、あなたは解雇される危機にあります。危機感を持って、仕様を守る修正対応してください。

レビューを受けた後、あなたはコーディング担当に戻る。必要な修正があれば追加修正する。

```zsh
LOG_LEVEL=debug deno test -A tests/level5/
```
