import { assertEquals, assertExists } from "../deps.ts";
import { fromFileUrl } from "@std/path";
import { BreakdownLogger as _BreakdownLogger } from "@tettuan/breakdownlogger";
import { schema } from "./schema.ts";

const _logger = new _BreakdownLogger("test-architecture-schema");

Deno.test("Architecture: schema.ts follows module boundary rules", () => {
  _logger.debug("アーキテクチャテスト開始: schema.ts", {
    testType: "architecture",
    target: "schema.ts",
  });

  // schemaオブジェクトが存在することを確認
  assertExists(schema);

  // schemaは定数オブジェクトとして定義されるべき
  assertEquals(typeof schema, "object");

  // 自己完結したモジュールであることを確認（他のローカルモジュールへの依存なし）
  const moduleCode = Deno.readTextFileSync(fromFileUrl(new URL("./schema.ts", import.meta.url)));
  const importLines = moduleCode.split("\n").filter((line) =>
    line.trim().startsWith("import") && !line.includes("@std/") && !line.includes("@tettuan/")
  );

  assertEquals(importLines.length, 0, "schema.ts should not import from local modules");
});

Deno.test("Architecture: schema.ts has no circular dependencies", () => {
  _logger.debug("循環参照チェック", {
    testType: "circular-dependency",
    target: "schema.ts",
  });

  // 自動生成ファイルのため、定義により循環参照は存在しない
  // ファイルに他のローカルファイルへのimportがないことを確認
  const moduleCode = Deno.readTextFileSync(fromFileUrl(new URL("./schema.ts", import.meta.url)));
  const hasLocalImports = moduleCode.includes('from "./') || moduleCode.includes("from '../");

  assertEquals(hasLocalImports, false, "schema.ts should not have local imports");
});

Deno.test("Architecture: schema.ts exports follow naming conventions", () => {
  _logger.debug("命名規則チェック", {
    testType: "naming-convention",
    target: "schema exports",
  });

  // エクスポートされた定数名が適切な命名規則に従っているか確認
  // "schema"は小文字で始まる定数名
  assertExists(schema);

  // schemaオブジェクトのキーはパス形式であるべき
  const keys = Object.keys(schema);
  keys.forEach((key) => {
    // キーは "category/type/filename.md" の形式
    const isValidPath = key.endsWith(".md") && key.includes("/");
    assertEquals(isValidPath, true, `Key "${key}" should be a valid path`);
  });
});

Deno.test("Architecture: schema.ts maintains proper layer separation", () => {
  _logger.debug("レイヤー分離チェック", {
    testType: "layer-separation",
    target: "schema.ts",
  });

  // schema.tsはデータ層として機能し、ビジネスロジックを含まない
  const moduleCode = Deno.readTextFileSync(fromFileUrl(new URL("./schema.ts", import.meta.url)));

  // ビジネスロジックの指標となるキーワードが含まれていないことを確認
  // (JSONデータ内の文字列は除外)
  const codeWithoutStrings = moduleCode.replace(/"[^"]*"/g, '""').replace(/'[^']*'/g, "''");
  const businessLogicKeywords = ["class", "function", "async", "await", "if (", "for (", "while ("];
  const hasBusinessLogic = businessLogicKeywords.some((keyword) =>
    codeWithoutStrings.includes(keyword)
  );

  assertEquals(hasBusinessLogic, false, "schema.ts should not contain business logic");

  // 純粋なデータ定義のみであることを確認
  assertEquals(moduleCode.includes("export const schema"), true, "Should export const schema");
});

Deno.test("Architecture: schema.ts follows single source of truth principle", () => {
  _logger.debug("単一情報源の原則チェック", {
    testType: "single-source-of-truth",
    target: "schema.ts",
  });

  // 自動生成ファイルであることを確認
  const moduleCode = Deno.readTextFileSync(fromFileUrl(new URL("./schema.ts", import.meta.url)));
  const isAutoGenerated = moduleCode.includes("This file is auto-generated");
  assertEquals(isAutoGenerated, true, "schema.ts should be marked as auto-generated");

  // スキーマデータが単一のエクスポートとして定義されていることを確認
  const exportCount = (moduleCode.match(/export\s+(const|let|var|function|class)/g) || []).length;
  assertEquals(exportCount, 1, "Should have exactly one export");

  // as constによる不変性が保証されていることを確認
  assertEquals(moduleCode.includes("} as const;"), true, "Should use 'as const' for immutability");
});
