import { exists } from "$std/fs/exists.ts";
import { ensureDir } from "$std/fs/ensure_dir.ts";
import { join, normalize, resolve } from "$std/path/mod.ts";
import { stringify, parse } from "$std/yaml/mod.ts";
import { BreakdownLogger } from "@tettuan/breakdownlogger";
import { Config as AppConfig, DEFAULT_CONFIG, PartialConfig } from "$lib/types/config.ts";

// Re-export the Config type from types
export type { Config } from "$lib/types/config.ts";

let config: Config | null = null;

/**
 * Environment variable mappings
 */
const ENV_MAPPINGS = {
  BREAKDOWN_WORKING_DIR: "working_dir",
  BREAKDOWN_PROMPT_DIR: "app_prompt.base_dir",
  BREAKDOWN_SCHEMA_DIR: "app_schema.base_dir",
} as const;

/**
 * Gets a nested value from an object using a dot-notation path
 * @param obj The object to get the value from
 * @param path The path to the value using dot notation (e.g. "server.port")
 * @returns The value at the specified path or undefined if not found
 */
export function getNestedValue(obj: Record<string, unknown>, path: string): unknown {
  return path.split(".").reduce((current: unknown, key: string) => {
    return current && typeof current === "object" 
      ? (current as Record<string, unknown>)[key]
      : undefined;
  }, obj);
}

/**
 * Sets a nested configuration value
 * @param obj Object to set value in
 * @param path Dot-separated path to value
 * @param value Value to set
 */
function setNestedValue(obj: Record<string, unknown>, path: string, value: unknown): void {
  const keys = path.split(".");
  const lastKey = keys.pop()!;
  const target = keys.reduce((current: Record<string, unknown>, key: string) => {
    if (!(key in current) || typeof current[key] !== "object") {
      current[key] = {};
    }
    return current[key] as Record<string, unknown>;
  }, obj);
  target[lastKey] = value;
}

/**
 * Normalizes configuration paths
 * @param cfg Configuration to normalize
 * @returns Normalized configuration
 */
function normalizeConfigPaths(cfg: Config): Config {
  const normalized = { ...cfg };
  
  // Normalize working directory
  normalized.working_dir = resolve(Deno.cwd(), normalize(cfg.working_dir));
  
  // Normalize prompt directory if exists
  if (cfg.app_prompt?.base_dir) {
    normalized.app_prompt = {
      base_dir: resolve(Deno.cwd(), normalize(cfg.app_prompt.base_dir)),
      debug: cfg.app_prompt.debug ?? false,
    };
  }
  
  // Normalize schema directory if exists
  if (cfg.app_schema?.base_dir) {
    normalized.app_schema = {
      base_dir: resolve(Deno.cwd(), normalize(cfg.app_schema.base_dir)),
    };
  }
  
  return normalized;
}

/**
 * Applies environment variable overrides to configuration
 * @param cfg Configuration to override
 * @returns Configuration with environment variables applied
 */
function applyEnvironmentOverrides(cfg: Config): Config {
  const overridden = { ...cfg };
  
  for (const [envVar, configPath] of Object.entries(ENV_MAPPINGS)) {
    const value = Deno.env.get(envVar);
    if (value) {
      setNestedValue(overridden as Record<string, unknown>, configPath, value);
    }
  }
  
  return overridden;
}

/**
 * Initializes the configuration
 * Creates default config if none exists
 */
export async function initializeConfig(): Promise<void> {
  const configDir = ".agent/breakdown/config";
  const configFile = join(configDir, "app.yml");

  try {
    // Create config directory if it doesn't exist
    await ensureDir(configDir);

    // Check if config file exists
    let loadedConfig: Config;
    if (!await exists(configFile)) {
      // Create default config file
      await Deno.writeTextFile(
        configFile,
        stringify(DEFAULT_CONFIG)
      );
      loadedConfig = { ...DEFAULT_CONFIG };
    } else {
      // Load existing config
      const content = await Deno.readTextFile(configFile);
      loadedConfig = parse(content) as Config;
    }

    // Apply environment overrides and normalize paths
    config = normalizeConfigPaths(applyEnvironmentOverrides(loadedConfig));

    // Validate config
    validateConfig(config);
  } catch (error) {
    throw new Error(`Failed to initialize config: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Gets the current configuration
 * Initializes config if not already loaded
 */
export function getConfig(): Config {
  if (!config) {
    throw new Error("Configuration not initialized. Run 'breakdown init' first.");
  }
  return config;
}

/**
 * Sets the configuration
 * @param newConfig New configuration to set
 */
export function setConfig(newConfig: Config): void {
  const normalized = normalizeConfigPaths(applyEnvironmentOverrides(newConfig));
  validateConfig(normalized);
  config = normalized;
}

/**
 * Validates the configuration object
 * @param cfg Configuration to validate
 * @throws Error if configuration is invalid
 */
function validateConfig(cfg: unknown): asserts cfg is Config {
  if (!cfg || typeof cfg !== "object") {
    throw new Error("Invalid configuration: must be an object");
  }

  const config = cfg as Record<string, unknown>;

  if (typeof config.working_dir !== "string") {
    throw new Error("Invalid configuration: working_dir must be a string");
  }

  if (config.app_prompt !== undefined) {
    if (typeof config.app_prompt !== "object" || config.app_prompt === null) {
      throw new Error("Invalid configuration: app_prompt must be an object");
    }

    const appPrompt = config.app_prompt as Record<string, unknown>;
    if (typeof appPrompt.base_dir !== "string") {
      throw new Error("Invalid configuration: app_prompt.base_dir must be a string");
    }
  }

  if (config.app_schema !== undefined) {
    if (typeof config.app_schema !== "object" || config.app_schema === null) {
      throw new Error("Invalid configuration: app_schema must be an object");
    }

    const appSchema = config.app_schema as Record<string, unknown>;
    if (typeof appSchema.base_dir !== "string") {
      throw new Error("Invalid configuration: app_schema.base_dir must be a string");
    }
  }
}

/**
 * Manages configuration for the application
 */
class ConfigManager {
  private logger: BreakdownLogger;
  private config: AppConfig;

  constructor() {
    this.logger = new BreakdownLogger();
    this.config = { ...DEFAULT_CONFIG };
  }

  public getConfig(): AppConfig {
    return this.config;
  }

  public updateConfig(newConfig: PartialConfig): void {
    const normalized = this.normalizeConfig(newConfig);
    this.config = normalized;
  }

  private normalizeConfig(config: PartialConfig): AppConfig {
    return {
      working_dir: config.working_dir ?? this.config.working_dir,
      app_prompt: {
        base_dir: config.app_prompt?.base_dir ?? this.config.app_prompt.base_dir,
        debug: config.app_prompt?.debug ?? this.config.app_prompt.debug
      },
      app_schema: {
        base_dir: config.app_schema?.base_dir ?? this.config.app_schema.base_dir
      }
    };
  }

  public toString(): string {
    return JSON.stringify(this.config, null, 2);
  }
}

// Global configuration instance
const configManager = new ConfigManager();

/**
 * Gets the current configuration
 */
export function getConfig(): AppConfig {
  return configManager.getConfig();
}

/**
 * Initializes the configuration with new values
 */
export function initializeConfig(newConfig: PartialConfig): void {
  configManager.updateConfig(newConfig);
} 