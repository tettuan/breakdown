/**
 * Build Resources Script
 *
 * This script reads the resource files (prompts) from the assets directory
 * and generates TypeScript files with the resources embedded as strings.
 *
 * SPEC-DIFF: Schema Processing Removal
 * - Schema definitions have been moved to a separate repository: https://github.com/tettuan/breakdownschema
 * - This library only handles file path resolution for schemas, not their content
 * - Schema-related code in this script should be removed in future updates
 */

import { ensureDir, exists } from "@std/fs";
import { dirname } from "@std/path/dirname";
import { join } from "@std/path/join";

// Paths
const ASSETS_DIR = "./assets";
const LIB_DIR = "./lib";
const PROMPTS_DIR = join(ASSETS_DIR, "prompts");
// SPEC-DIFF: To be removed - Schema directory references
const SCHEMAS_DIR = join(ASSETS_DIR, "schemas");
const PROMPTS_OUTPUT = join(LIB_DIR, "prompts", "templates.ts");
// SPEC-DIFF: To be removed - Schema output reference
const SCHEMAS_OUTPUT = join(LIB_DIR, "schemas", "definitions.ts");

// Generate templates.ts
async function generatePromptTemplates() {
  if (!await exists(PROMPTS_DIR)) {
    console.error(`Prompts directory not found: ${PROMPTS_DIR}`);
    return;
  }

  let output = `/**
 * Generated Prompt Templates
 * 
 * This file is auto-generated from the assets/prompts directory.
 * Do not edit this file directly.
 */

export const PROMPTS = {
`;

  // Read all prompt files
  for await (const entry of Deno.readDir(PROMPTS_DIR)) {
    if (entry.isDirectory) {
      const commandType = entry.name;
      output += `  ${commandType}: {\n`;

      const commandDir = join(PROMPTS_DIR, commandType);
      for await (const layerEntry of Deno.readDir(commandDir)) {
        if (layerEntry.isDirectory) {
          const layerType = layerEntry.name;
          const promptFile = join(commandDir, layerType, "base.md");

          if (await exists(promptFile)) {
            const content = await Deno.readTextFile(promptFile);
            // Escape backticks and format the string
            const escapedContent = content.replace(/`/g, "\\`");
            output += `    ${layerType}: \`${escapedContent}\`,\n`;
          }
        }
      }

      output += `  },\n`;
    }
  }

  output += `};\n`;

  // Ensure the output directory exists
  await ensureDir(dirname(PROMPTS_OUTPUT));

  // Write the output file
  await Deno.writeTextFile(PROMPTS_OUTPUT, output);
}

// SPEC-DIFF: To be removed - Schema generation function
// This functionality should be moved to the breakdownschema repository
async function generateSchemaDefinitions() {
  if (!await exists(SCHEMAS_DIR)) {
    console.error(`Schemas directory not found: ${SCHEMAS_DIR}`);
    return;
  }

  let output = `/**
 * Generated Schema Definitions
 *
 * This file is auto-generated from the assets/schemas directory.
 * Do not edit this file directly.
 */

export const schemas = {
`;

  // Read all schema files
  for await (const entry of Deno.readDir(SCHEMAS_DIR)) {
    if (entry.isDirectory) {
      const commandType = entry.name;
      const commandDir = join(SCHEMAS_DIR, commandType);
      const hasSchemas = Array.from(Deno.readDirSync(commandDir)).some((e) => e.isDirectory);

      if (!hasSchemas) {
        // For empty directories, output a simple empty object
        output += `  ${commandType}: {},\n`;
        continue;
      }

      output += `  ${commandType}: {\n`;

      for await (const layerEntry of Deno.readDir(commandDir)) {
        if (layerEntry.isDirectory) {
          const layerType = layerEntry.name;
          const schemaFile = join(commandDir, layerType, "base.schema.json");

          if (await exists(schemaFile)) {
            const content = await Deno.readTextFile(schemaFile);
            // Parse and stringify to ensure valid JSON and proper formatting
            const schema = JSON.parse(content);
            const jsonString = JSON.stringify(schema, null, 2)
              .replace(/`/g, "\\`")
              .replace(/\$/g, "\\$")
              .split("\n")
              .map((line) => "    " + line) // Proper indentation for template strings
              .join("\n");

            output += `    ${layerType}: \`${jsonString}\`,\n`;
          }
        }
      }

      output += `  },\n`;
    }
  }

  output += `};\n`; // Ensure final newline

  // Ensure the output directory exists
  await ensureDir(dirname(SCHEMAS_OUTPUT));

  // Write the output file
  await Deno.writeTextFile(SCHEMAS_OUTPUT, output);
}

// Main function
async function main() {
  try {
    await generatePromptTemplates();
    // SPEC-DIFF: To be removed - Schema generation call
    await generateSchemaDefinitions();
  } catch (error) {
    throw error;
  }
}

// Run the script
if (import.meta.main) {
  await main();
}
